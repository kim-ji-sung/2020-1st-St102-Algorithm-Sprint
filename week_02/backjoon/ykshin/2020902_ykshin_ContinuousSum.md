# {연속합}

## 문제 설명
주어진 수열에서, 연속되는 부분합중 가장 큰 값을 구하는 문제

## 나의 풀이 방법
수열에서 바로 이전값이 음수가 아니고, 본인과 더했을 때 0 이상이라면 이전 값과 본인을 더해도 가치가 있다는 뜻이다.
만약 이전 값이 음수라면, 현재 수에 더해도 가치가 없고, 현재수부터 다시 수열을 시작하는게 의미있다.
만약 이전 값이 음수가 아닌데, 본인이 음수라 하더라도 만약 더했을 때 0이상이라면 다음 값 한테 의미가 있는 값이 될 수 있기에 더한다.
수열을 한바퀴 돌면서 각 상태가 max보다 크면 최고 값을 갱신한다.
```kotlin
    var max = sequence[0]
    for(i in 1 until n){
        if(sequence[i-1]>0&&sequence[i]+sequence[i-1]>0){
            sequence[i]+=sequence[i-1]
        }
        if(max<sequence[i]){
            max = sequence[i]
        }
    }
```

## 다른 사람의 풀이 방법
나도 사실상 dp를 이용한 풀이 방법이지만, 따로 배열은 선언하지 않았다. 해당 방법은 dp배열을 따로 만들어서 처리했지만, 해당 문제의 경우 원래 있는 배열을 그대로 사용해서 처리할 수 있기 때문에 공간복잡도로 유리하다.
```cpp
    dp[0] = arr[0];
    ans = dp[0];

    for (i = 1; i < n; i++) {
        dp[i] = max(dp[i-1] + arr[i], arr[i]);
        ans = max(ans, dp[i]);
    }
```
## 배운 점
- stringTokenizer 를 이용한 배열 초기화

## 반성할 점
- 부분합 문제면 dp를 먼저 떠올리자.

## Action Item
- 문제가 어떤 분류의 유형일지 생각하자!