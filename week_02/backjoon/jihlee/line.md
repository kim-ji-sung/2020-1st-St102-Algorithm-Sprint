한 줄로 서기
=========

## 문제 설명

왼쪽에 자신보다 큰 키의 정보를 이용하여 자신의 위치를 찾기


## 나의 풀이 방법

```c++
    for (int i = 0; i < peopleNum; i++) {
        int mysit = -1;
        for (int j = 0; j < peopleNum; j++) {
            if (line[j] == -1)
                mysit++;
            if (mysit == order[i]) {
                line[j] = i + 1;
                break;
            }
        }
    }
```
**그리디 알고리즘**을 이용하여 자신의 위치를 시작부터 끝까지 그리디하게 찾는다. 작은 숫자부터 자리를 찾기 시작하는데 시작부터 비어있는 자리의 숫자가 자신보다 큰 사람의 수와 일치하는 지점에 해당 숫자를 채워넣는다. 

## 다른 사람의 풀이 방법
```c++
for (int i = n - 1; i >= 0; --i) {
    vector<int>::iter iter = sol.begin();
    for (int k = 0; k < order[i]; ++k)
        iter++;
    sol.insert(iter, i + 1);
}
```
이 풀이 방법은 배열 대신 sol 벡터에 큰 키부터 반대로 채워 넣는 점이 내 풀이 방법과 다르다. 큰 키부터 채우면 빈 자리를 보지 않고도 sol 벡터에 자기보다 큰키를 수 자리에 삽입만 하면 된다. 

참고 사이트: <https://kibbomi.tistory.com/20>


## 배운점 

-거꾸로 그리디 기준을 잡아도 더 편하게 구할 수 있는 걸을 보고 어떤 기준을 그리디 기준으로 잡을 지는 같은 문제라도 다양할 수 있다는 것을 알았다. 

